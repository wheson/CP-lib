{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"Procon Template": {
		"prefix": "kyoupro",
		"body":[
			"#include <bits/stdc++.h>",
			"//#define int long long",
			"",
			"using namespace std;",
			"using LL = long long;",
			"using P = pair<int, int>;",
			"",
			"#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)",
			"#define REP(i, n) FOR(i, 0, n)",
			"",
			"#define pb(a) push_back(a)",
			"#define all(x) (x).begin(),(x).end()",
			"",
			"const int INF = (int)1e9;",
			"const LL INFL = (LL)1e19;",
			"const int MOD = 1e9 + 7;",
			"",
			"signed main()",
			"{",
			"    cin.tie(0);",
    		"    ios::sync_with_stdio(false);",
			"    ${1}",
			"}"
		],
		"description": "競プロテンプレート"
	},
	"UnionFind" : {
		"prefix": "unionfind",
		"body": [
			"// UnionFindを構築します",
			"// 使用例:",
			"// UnionFind uni(n);",
			"// cout << uni.Same(1, 2) ? \"YES\" : \"NO\" << endl; <- NO",
			"// uni.Unite(1, 2);",
			"// cout << uni.Same(1, 2) ? \"YES\" : \"NO\" << endl; <- YES",
			"// cout << uni.GetSize(1) << endl;                <- 2",
			"class UnionFind",
			"{",
			"    private:",
			"      vector<int> par;",
			"      vector<int> rank;",
			"      vector<int> sz;",
			"",
			"    public:",
			"      UnionFind(int n) : par(n), rank(n, 0), sz(n, 1)",
			"      {",
			"          iota(par.begin(), par.end(), 0);",
			"      }",
			"      int Find(int x)",
			"      {",
			"          if (par[x] == x) return x;",
			"          else",
			"          {",
			"              int r = Find(par[x]);",
			"              return par[x] = r;",
			"          }",
			"      }",
			"      bool Unite(int x, int y)",
			"      {",
			"          x = Find(x);",
			"          y = Find(y);",
			"          if (x == y) return false;",
			"",
			"          if (rank[x] < rank[y]) swap(x, y);",
			"          par[y] = x;",
			"          if (rank[x] == rank[y]) rank[x]++;",
			"          sz[x] += sz[y];",
			"          return true;",
			"      }",
			"      bool Same(int x, int y)",
			"      {",
			"          if (Find(x) == Find(y)) return true;",
			"          else return false;",
			"      }",
			"      int GetSize(int x)",
			"      {",
			"          return sz[Find(x)];",
			"      }",
			"};",
		],
		"description": "UnionFind"
	},
	"Countings" : {
		"prefix": "countings",
		"body": [
			"// 順列・組合せ・重複組合せを計算します",
			"// 構築 O(N)，計算結果取得 O(1)",
			"// 使用例:",
			"// Countings ct(MAX_N, MOD);",
			"// cout << ct.Permutation(10, 5) << endl;        <- 10P5 = 30240",
			"// cout << ct.Combination(10, 5) << endl;        <- 10C5 = 252",
			"// cout << ct.HomogeneousProduct(10, 5) << endl; <- 10H5 = 2002",
			"class Countings",
			"{",
			"  private:",
			"    int mod;",
			"    vector<long long> factList, invList;",
			"    long long Pow(long long x, long long n)",
			"    {",
			"        long long ret = 1;",
			"        while (n > 0)",
			"        {",
			"            if (n & 1) ret = ret * x % mod;",
			"            x = x * x % mod;",
			"            n >>= 1;",
			"        }",
			"        return ret;",
			"    }",
			"",
			"  public:",
			"    Countings(int sz, int mod) : mod(mod), factList(sz + 1), invList(sz + 1)",
			"    {",
			"        factList[0] = 1;",
			"        for (int i = 1; i < factList.size(); i++)",
			"        {",
			"            factList[i] = factList[i - 1] * i % mod;",
			"        }",
			"        invList[sz] = Pow(factList[sz], mod - 2);",
			"        for (int i = sz - 1; i >= 0; i--)",
			"        {",
			"            invList[i] = invList[i + 1] * (i + 1) % mod;",
			"        }",
			"    }",
			"    long long Permutation(int n, int r)",
			"    {",
			"        if (r < 0 || n < r) return 0;",
			"        return factList[n] * invList[n - r] % mod;",
			"    }",
			"    long long Combination(int n, int r)",
			"    {",
			"        if (r < 0 || n < r) return 0;",
			"        return factList[n] * invList[r] % mod * invList[n - r] % mod;",
			"    }",
			"    long long HomogeneousProduct(int n, int r){",
			"        if (n < 0 || r < 0) return 0;",
			"        return (r == 0 ? 1 : Combination(n + r - 1, r));",
			"    }",
			"};"
		]
	},
	"Dijkstra" : {
		"prefix": "dijkstra",
		"body": [
			"// 単一始点最短経路(ダイクストラ法)",
			"// 時間計算量はO((V+E)logV)",
			"// 使用例:",
			"// Dijkstra<int> dij(N);",
			"// dij.AddEdge(f, t, c);  <- fからtのコストcの辺を追加",
			"// dij.Run(s);            <- s始点での最短経路長",
			"// dij.cost[t]            <- Run()で求めた始点からtへの最短経路長を取得",
			"// dij.HasPath(t)         <- Run()で求めた始点からtへのパスは存在するか",
			"// dij.GetShortestPath(t) <- Run()で求めた始点からtへのパスを取得",
			"template <typename T>",
			"struct Edge",
			"{",
			"    int from, to;",
			"    T cost;",
			"    Edge(int to, T cost) : from(-1), to(to), cost(cost) {}",
			"    Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}",
			"};",
			"",
			"template <typename T>",
			"using Edges = vector<Edge<T>>;",
			"template <typename T>",
			"using AdjList = vector<Edges<T>>;",
			"",
			"template <typename T>",
			"class Dijkstra",
			"{",
			"  private:",
			"    T INF = numeric_limits<T>::max() / 10;",
			"    int V;",
			"    AdjList<T> adj;",
			"    vector<int> prever;",
			"",
			"  public:",
			"    Dijkstra(int n) : V(n + 1), adj(V), prever(vector<int>(V, -1)), cost(V, INF) {}",
			"    vector<T> cost;",
			"    void AddEdge(int f, int t, int c)",
			"    {",
			"        adj[f].push_back(Edge<T>(t, c));",
			"    }",
			"    bool HasPath(int t)",
			"    {",
			"        return cost[t] != INF;",
			"    }",
			"    vector<int> GetShortestPath(int t)",
			"    {",
			"        vector<int> path;",
			"        for (; t != -1; t = prever[t]) path.push_back(t);",
			"        reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"    void Run(int f)",
			"    {",
			"        cost.assign(V, INF);",
			"        prever.assign(V, -1);",
			"",
			"        using Pi = pair<T, int>;",
			"        priority_queue<Pi, vector<Pi>, greater<Pi>> pq;",
			"",
			"        cost[f] = 0;",
			"        pq.push(Pi(cost[f], f));",
			"",
			"        while (!pq.empty())",
			"        {",
			"            Pi currentEdge = pq.top();",
			"            pq.pop();",
			"            if (cost[currentEdge.second] < currentEdge.first) continue;",
			"",
			"            for (Edge<T> tmp : adj[currentEdge.second])",
			"            {",
			"                T sumCost = currentEdge.first + tmp.cost;",
			"                if (cost[tmp.to] > sumCost)",
			"                {",
			"                    cost[tmp.to] = sumCost;",
			"                    prever[tmp.to] = currentEdge.second;",
			"                    pq.push(Pi(cost[tmp.to], tmp.to));",
			"                }",
			"            }",
			"        }",
			"    }",
			"};"
		]
    },
    "RollingHash" :{
        "prefix" : "rollinghash",
        "body" : [
            "// Rabin-Karp string search algorithm",
            "class RollingHash{",
            "  private:",
            "    using ULL = unsigned long long;",
            "    int n;",
            "    const ULL mod = 1ULL << 63;",
            "    const ULL base = 1000000007ULL;",
            "    vector<ULL> hash, power;",
            "  public:",
            "    RollingHash(string s){",
            "        n = s.size();",
            "        hash.assign(n+1, 0ULL);",
            "        power.assign(n+1, 0ULL);",
            "        power[0] = 1ULL; ",
            "        for(int i = 0; i < n; i++){",
            "            power[i+1] = power[i] * base % mod;",
            "            hash[i+1] = (s[i] + hash[i] * base) % mod;",
            "        }",
            "    }",
            "    ULL GetHash(int l, int r){",
            "        return ((hash[r] - hash[l] * power[r-l]) % mod + mod) % mod;",
            "    }",
            "};"
        ]
    }
}